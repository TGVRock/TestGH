import{l as f,f as p,e as i,C as y}from"./index-63135a25.js";const r=f(),c=p();function g(t){return i.Address.isValidRawAddress(t)}function m(t,e){try{return i.Account.createFromPrivateKey(t,e)}catch{}}async function h(t){const e="get test account info:",s=new i.RepositoryFactoryHttp(c.getTestNetNode()).createAccountRepository();if(!g(t)){r.logger.error(e,"invalid address.",t);return}const u=i.Address.createFromRawAddress(t);return await s.getAccountInfo(u).toPromise().then(a=>a).catch(a=>{r.logger.error(e,"failed.",a)})}async function w(t){const e="announce test account public key:",o=new i.RepositoryFactoryHttp(c.getTestNetNode()),s=o.createTransactionRepository();if(t.networkType!==i.NetworkType.TEST_NET)return r.logger.error(e,"not testnet account."),!1;const u=await o.getGenerationHash().toPromise().then(n=>n).catch(n=>{r.logger.error(e,"failed.",n)});if(typeof u>"u")return r.logger.error(e,"get generationHash failed."),!1;const a=await o.getEpochAdjustment().toPromise().then(n=>n).catch(n=>{r.logger.error(e,"failed.",n)});if(typeof a>"u")return r.logger.error(e,"get epochAdjustment failed."),!1;const l=i.TransferTransaction.create(i.Deadline.create(a),t.address,[],i.EmptyMessage,i.NetworkType.TEST_NET).setMaxFee(y.TX_FEE_MULTIPLIER_DEFAULT),d=t.sign(l,u);return r.logger.debug(e,"now announce.",d),s.announce(d).toPromise().then(n=>(r.logger.debug(e,"announced.",n),typeof n>"u"?(r.logger.error(e,"announce failed."),!1):!0)).catch(n=>(r.logger.error(e,"failed.",n),!1))}async function v(t){const e="get account info:";if(typeof c.accountRepo>"u"){r.logger.error(e,"repository undefined.");return}if(!g(t)){r.logger.error(e,"invalid address.",t);return}const o=i.Address.createFromRawAddress(t);return await c.accountRepo.getAccountInfo(o).toPromise().then(s=>s).catch(s=>{r.logger.error(e,"failed.",s)})}async function A(t){const e="get multisig info:";if(typeof c.multisigRepo>"u"){r.logger.error(e,"repository undefined.");return}if(!g(t)){r.logger.error(e,"invalid address.",t);return}return await c.multisigRepo.getMultisigAccountInfo(i.Address.createFromRawAddress(t)).toPromise().then(o=>o).catch(o=>{r.logger.error(e,"failed.",o)})}async function R(t){const e="get multisig addresses:",o=await A(t);return typeof o>"u"?(r.logger.error(e,"get multisig info failed.",t),[]):o.isMultisig()?(r.logger.debug(e,"address is multisig account.",t),[]):o.multisigAddresses}export{A as a,R as b,m as c,h as d,w as e,v as g,g as i};
